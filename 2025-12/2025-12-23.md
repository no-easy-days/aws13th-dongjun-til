# [2025-12-23]

## ☀️ 오늘의 목표 (Scrum)

> 아침 스크럼이나 오늘 꼭 달성하고 싶은 목표를 적습니다.
>
- [ ]  목표 1 변수와 자료형
- [ ]  목표 2 조건문과 반복문

## 📝 배운 내용 (Today I Learned)

## 주제 1) 변수와 자료형
(int, float, str, bool, list, dict, tuple, set)


### 1) 변수란 무엇인가
(단순 “상자”보다 정확한 정의)

변수는 값 자체가 아니라,
값(객체)을 가리키는 이름(참조)이다.

Python에서는
이름 → 객체 로 연결되는
바인딩(binding) 관점이 중요하다.
```python
    a = 10
```
위 코드는
“10을 a에 넣는다”라기보다
“정수 객체 10을 a라는 이름이 참조한다”
라는 의미에 가깝다.

### 2) 타입(type)의 의미

타입은 단순한 “모양”이 아니라
다음 요소들의 조합이다.

- 허용되는 연산의 집합
- 내부 표현(저장 방식)
- 동작 규칙

예시:
- int  : 덧셈, 뺄셈, 비트 연산 가능
- str  : 결합, 슬라이싱 가능
- 서로 다른 타입이 섞이면
  암묵적 형 변환 규칙이 적용된다


### 3) 불변(immutable) vs 가변(mutable)
(실수의 핵심 원인)

불변(immutable)
- int, float, str, bool, tuple
- 값이 바뀌는 것처럼 보여도
  실제로는 새 객체를 만들어 재바인딩한다

가변(mutable)
- list, dict, set
- 객체 내부 상태가 직접 변경된다
- 같은 객체를 여러 변수가 참조하면
  변경이 함께 전파된다

```python
    a = [1, 2]
    b = a
    b.append(3)
```
```python
    #결과:
    a → [1, 2, 3]
    b → [1, 2, 3]

```

### 4) 각 자료형 심화 포인트

(1) int
- 임의 정밀도 정수
- overflow 걱정이 상대적으로 적다
- /  : float 나눗셈
- // : 정수 나눗셈 (몫)

(2) float
- 부동소수점 오차가 존재한다
- 정확한 실수가 아니다

예시:
    0.1 + 0.2 == 0.3
    → False일 수 있음

따라서 실수 비교 시
== 사용에 주의해야 한다

(3) str
- 불변 타입
- 반복문에서 += 사용 시
  성능 저하 가능
- 슬라이싱은 항상
  새로운 문자열을 생성한다

(4) bool
- True / False 논리 타입
- Python에서는 정수처럼 취급됨

예시:
    True  == 1
    False == 0

Falsy 값:
- 0, 0.0, ""
- [], {}, set()
- None

그 외 대부분은 Truthy

(5) list
- 순서 O, 중복 O, 가변
- append(): 평균 O(1)
- insert(0, x): O(n)
- 얕은 복사 주의

예시:
    b = a[:]
    b = a.copy()

(6) dict
- 키-값 구조
- 평균 조회 시간 O(1)
- 키는 반드시 hashable 해야 함
  (보통 불변 타입)

자주 쓰는 패턴:
    if key in d:
    value = d.get(key, default)
    d[key] = d.get(key, 0) + 1

(7) tuple
- 순서 O, 중복 O, 불변
- 고정 데이터 묶음에 사용
- dict의 키로 활용 가능
- 단, 내부에 list가 있으면
  그 list는 변경 가능

(8) set
- 순서 개념 없음
- 중복 허용 안 함
- 포함 검사 O(1)
- 중복 제거에 매우 유용

집합 연산:
- 합집합  |
- 교집합  &
- 차집합  -

## 주제 2) 조건문과 반복문 (if, for, while)
1) if의 본질: 분기(branch)

핵심은 조건의 참/거짓 판정과 분기 경로의 명확성.

좋은 습관:

조건을 “의미 있는 이름”으로 분리해 가독성 확보

중첩 if를 줄이고 “조기 종료(early return)” 고려(함수에서 특히)

### 나쁜 예: 중첩이 깊음
```python
    if user:
      if user.is_active:
          if user.role == "admin":
            ...
```
### 개선: 의미를 먼저 드러냄
```python
if not user:
    ...
if not user.is_active:
    ...
if user.role != "admin":
    ...
```

2) for의 본질: “컬렉션/시퀀스” 순회

Python의 for는 인덱스 기반이라기보다 이터러블(iterable)을 순회한다.

대표 패턴:

인덱스 필요: for i, v in enumerate(lst):

병렬 순회: for a, b in zip(A, B):

필터/변환: 리스트 컴프리헨션
```python
    squares = [x*x for x in nums if x % 2 == 0]
```

3) while의 본질: “조건이 유지되는 동안” 반복

종료 조건을 스스로 보장해야 한다(무한 루프 위험).

자주 쓰는 형태:

입력이 올 때까지

상태가 특정 조건이 될 때까지

BFS/스택 처리에서 “큐가 빌 때까지”
```python
    while queue:
      cur = queue.pop(0)
```

4) break / continue / else

break: 반복 즉시 종료

continue: 이번 회차만 스킵하고 다음 회차로

for-else: break 없이 끝나면 else 실행(의외로 유용)
```python
    for x in nums:
      if x == target:
        found = True
        break
      else:
        found = False  # 끝까지 못 찾음(중간 break 없음)
```

5) 복잡도 감각(심화지만 매우 중요)

“반복문이 몇 번 도는가”는 성능의 뼈대.

단일 루프: O(n)

이중 루프: O(n²)

dict/set 포함 검사: 평균 O(1)라서 “이중 루프를 줄이는” 핵심 도구가 됨


## 💭 오늘의 회고 (Retrospective)

- **Keep (좋았던 점)**:
- **Problem (아쉬웠던 점)**:
- **Try (시도할 점)**:

## 🔗 참고 자료 (References)
